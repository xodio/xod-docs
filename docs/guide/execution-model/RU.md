---
title: Модель исполнения в деталях
---

# Модель исполнения в деталях

В отличие от обычного программирования, XOD является языком потока данных, а не языком потока управления. Это означает, что нет такой вещи, как указатель/инструкции, которые бы определяли, какая команда будет выполнена в следующий момент. Вместо этого обновления выполняются в полу-мгновенных _транзакциях_, в которых все данные вычисляются одновременно.

## Жизненный цикл программы

В любой конкретный момент программа XOD либо находится в транзакции, либо в состоянии ожидания.

В режиме ожидания система остается стабильной, ничего не меняется. Плата может даже засыпать, чтобы сохранить батарею. Получение нового внешнего сигнала от ноды, такой как системные часы или датчик, является причиной того, что программа выйдет из состояния ожидания.

Сигнал заставляет программу ввезти новую _транзакцию_. Обновленные значения перемещаются вниз по линкам и заставляют обновиться ноды с которыми они связаны. Процесс обновления нод называется _вычислением_ в XOD.

После вычисления всех нод, затронутых обновлением, транзакция завершена, и система возвращается в состояние ожидания.

## Правила транзакции

### Нет внешних сигналов во время транзакции

Сама транзакция предотвращает возникновение любого внешнего обновления во время текущей транзакции. Такой сигнал будет отложен и инициирует новую транзакцию после завершения текущей транзакции.

### Порядок вычислений

Во время транзакции нода вычисляется только после того, как все ноды, влияющие на неё будут вычислены.

Рассмотрим следующий пример.

![Diamond graph](./abc.patch.png)

Результирующая нода будет вычислена только после вычисления обеих ветвей, несмотря на то, что они имеют цепочки нод разной длины. Вы не можете знать порядок, в котором будут вычисляться ветви. Это могут быть M1-M2-M3, M3-M1-M2, M1-M3-M2 или даже M1-M2 и M3 параллельно. Кроме того, вычисление результирующей ноды может быть отложено до тех пор, пока не будут необходимы её значения (так называемая “ленивое вычисление”).

Единственное, что имеет значение, это то, что нода никогда не будет вычислена с неполными данными.

Именно по этой причине входы не могут иметь более одной входящей ссылки. В противном случае возникла бы двусмысленность, если две или несколько линков попытались бы доставить разные значения.

### Буферизация

Выходы нод _буферизуются_ при изменении. Другими словами, выходы сохраняют самое последнее значение. Данные сохраняются между транзакциями. "Таким образом, имея ноду с несколькими входами, при изменении значения на одном из входов, значения на неизменившихся входах нода будет "видеть" как буферизованные из предыдущих транзакций по линкам.

<div class="ui segment">
<span class="ui ribbon label">Для профи</span>
Если вы знакомы с обычным программированием, думайте о пинах и их буферизированных значениях в 
качестве <em>переменных</em>. Они сохраняют состояние программы и изменяются со временем.
</div>

### Обработка обратной связи

Ссылка, которая прямо или косвенно возвращается к вышестоящей ноде, создает цикл также известный как цикл графа. Такие ссылки нарушают правила потому, что их порядок вычислений становится неоднозначным: каждая нода в цикле зависит от самой себя. Для решения проблемы существует специальная нода `defer`. Она передает полученное значение по исходящей ссылке на следующую транзакцию. Другими словами, XOD поддерживает циклы обратной связи, но путь цикла должен имейте по крайней мере одну `defer` ноду для уточнения правильного порядка вычислений.

## Итог

Жизненный цикл программы можно рассматривать как бесконечную серию транзакций, которые выполняются всякий раз, когда происходит внешнее воздействие.

Транзакции защищены от внезапных эффектов, которые могут изменить или сделать неоднозначным порядок вычисления нод.
